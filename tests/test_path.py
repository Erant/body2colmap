"""
Tests for orbit path generation and original-camera pinning.
"""

import numpy as np
import pytest

from body2colmap import coordinates
from body2colmap.camera import Camera
from body2colmap.path import OrbitPath, compute_original_camera_orbit_params


class TestCartesianToSpherical:
    """Test cartesian_to_spherical inverse of spherical_to_cartesian."""

    def test_roundtrip_basic(self):
        """spherical -> cartesian -> spherical should be identity."""
        radius, azimuth, elevation = 5.0, 45.0, 30.0
        cart = coordinates.spherical_to_cartesian(radius, azimuth, elevation)
        r2, a2, e2 = coordinates.cartesian_to_spherical(cart)
        assert np.isclose(r2, radius, atol=1e-5)
        assert np.isclose(a2, azimuth, atol=1e-5)
        assert np.isclose(e2, elevation, atol=1e-5)

    def test_roundtrip_negative_azimuth(self):
        """Handles negative Z (azimuth near 180)."""
        radius, azimuth, elevation = 3.0, 170.0, -10.0
        cart = coordinates.spherical_to_cartesian(radius, azimuth, elevation)
        r2, a2, e2 = coordinates.cartesian_to_spherical(cart)
        assert np.isclose(r2, radius, atol=1e-5)
        assert np.isclose(a2, azimuth, atol=1e-5)
        assert np.isclose(e2, elevation, atol=1e-5)

    def test_origin_returns_zeros(self):
        """Zero vector should return all zeros."""
        r, a, e = coordinates.cartesian_to_spherical(np.zeros(3))
        assert r == 0.0
        assert a == 0.0
        assert e == 0.0

    def test_pure_up(self):
        """Point straight up should have elevation 90."""
        r, a, e = coordinates.cartesian_to_spherical(np.array([0, 5, 0]))
        assert np.isclose(r, 5.0, atol=1e-5)
        assert np.isclose(e, 90.0, atol=1e-5)

    def test_plus_z(self):
        """Point along +Z should have azimuth 0."""
        r, a, e = coordinates.cartesian_to_spherical(np.array([0, 0, 3]))
        assert np.isclose(r, 3.0, atol=1e-5)
        assert np.isclose(a, 0.0, atol=1e-5)
        assert np.isclose(e, 0.0, atol=1e-5)


class TestComputeOriginalCameraOrbitParams:
    """Test the standalone orbit parameter computation."""

    def test_camera_at_origin_target_along_negative_z(self):
        """Standard SAM-3D-Body case: camera at origin, mesh along -Z."""
        target = np.array([0.0, 0.0, -2.0], dtype=np.float32)
        params = compute_original_camera_orbit_params(target)

        # Distance from origin to target
        assert np.isclose(params['radius'], 2.0, atol=1e-5)
        # Camera is at origin, target at [0,0,-2], so offset is [0,0,+2]
        # That's along +Z -> azimuth 0
        assert np.isclose(params['start_azimuth_deg'], 0.0, atol=1e-3)
        assert np.isclose(params['elevation_deg'], 0.0, atol=1e-3)

    def test_camera_at_origin_target_off_axis(self):
        """Mesh center slightly off the -Z axis."""
        target = np.array([0.1, -0.2, -1.5], dtype=np.float32)
        params = compute_original_camera_orbit_params(target)

        # Verify roundtrip: spherical -> cartesian gives back the offset
        offset_expected = -target  # camera(origin) - target
        offset_recovered = coordinates.spherical_to_cartesian(
            params['radius'], params['start_azimuth_deg'], params['elevation_deg']
        )
        assert np.allclose(offset_recovered, offset_expected, atol=1e-4)

    def test_custom_camera_position(self):
        """Non-origin camera position."""
        target = np.array([1.0, 0.0, 0.0], dtype=np.float32)
        camera_pos = np.array([4.0, 0.0, 0.0], dtype=np.float32)
        params = compute_original_camera_orbit_params(target, camera_pos)

        # Offset is [3, 0, 0] -> azimuth 90, elevation 0
        assert np.isclose(params['radius'], 3.0, atol=1e-5)
        assert np.isclose(params['start_azimuth_deg'], 90.0, atol=1e-3)
        assert np.isclose(params['elevation_deg'], 0.0, atol=1e-3)


class TestOrbitPathPinFirstCamera:
    """Test pin_first_camera functionality on OrbitPath."""

    def _make_pin_camera(self):
        """Create a pin camera (identity pose, at origin)."""
        return Camera(
            focal_length=(500.0, 500.0),
            image_size=(512, 512),
            position=np.zeros(3, dtype=np.float32),
            rotation=np.eye(3, dtype=np.float32)
        )

    def test_circular_without_pin(self):
        """Without pin, frame 0 is a freshly-created camera (not the pin object)."""
        pin = self._make_pin_camera()
        orbit = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0
            # No pin_first_camera
        )
        cameras = orbit.circular(n_frames=10, elevation_deg=0.0, overlap=0)
        # Frame 0 is NOT the pin object (it was generated by the orbit)
        assert cameras[0] is not pin

    def test_circular_with_pin(self):
        """With pin, frame 0 is exactly the pinned camera."""
        pin = self._make_pin_camera()
        orbit = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0,
            pin_first_camera=pin
        )
        cameras = orbit.circular(n_frames=10, elevation_deg=0.0, overlap=0)

        assert cameras[0] is pin
        assert np.allclose(cameras[0].position, [0, 0, 0])
        assert np.allclose(cameras[0].rotation, np.eye(3))
        # Other frames are not pinned
        assert cameras[1] is not pin
        assert not np.allclose(cameras[1].position, [0, 0, 0])

    def test_sinusoidal_with_pin(self):
        """Pin works with sinusoidal path."""
        pin = self._make_pin_camera()
        orbit = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0,
            pin_first_camera=pin
        )
        cameras = orbit.sinusoidal(n_frames=10)

        assert cameras[0] is pin
        assert cameras[1] is not pin

    def test_helical_with_pin(self):
        """Pin works with helical path."""
        pin = self._make_pin_camera()
        orbit = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0,
            pin_first_camera=pin
        )
        cameras = orbit.helical(n_frames=10)

        assert cameras[0] is pin
        assert cameras[1] is not pin

    def test_pin_does_not_affect_frame_count(self):
        """Pinning should not change the total number of frames."""
        pin = self._make_pin_camera()
        orbit_pinned = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0,
            pin_first_camera=pin
        )
        orbit_normal = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0
        )

        n = 20
        assert len(orbit_pinned.circular(n_frames=n, overlap=0)) == n
        assert len(orbit_normal.circular(n_frames=n, overlap=0)) == n

    def test_pin_preserves_intrinsics(self):
        """Pinned camera keeps its own intrinsics (not the template's)."""
        pin = Camera(
            focal_length=(800.0, 800.0),
            image_size=(720, 1280),
            position=np.zeros(3, dtype=np.float32),
            rotation=np.eye(3, dtype=np.float32)
        )
        template = Camera(
            focal_length=(500.0, 500.0),
            image_size=(512, 512)
        )
        orbit = OrbitPath(
            target=np.array([0, 0, -2], dtype=np.float32),
            radius=2.0,
            pin_first_camera=pin
        )
        cameras = orbit.circular(
            n_frames=10, overlap=0, camera_template=template
        )

        # Frame 0 has pin's intrinsics
        assert cameras[0].fx == 800.0
        assert cameras[0].width == 720
        # Frame 1 has template's intrinsics
        assert cameras[1].fx == 500.0
        assert cameras[1].width == 512


class TestOrbitPathCircular:
    """Test basic circular orbit generation."""

    def test_frame_count(self):
        """Should generate requested number of frames."""
        orbit = OrbitPath(
            target=np.zeros(3, dtype=np.float32),
            radius=5.0
        )
        cameras = orbit.circular(n_frames=30, overlap=0)
        assert len(cameras) == 30

    def test_frame_count_with_overlap(self):
        """Overlap should produce correct total frame count."""
        orbit = OrbitPath(
            target=np.zeros(3, dtype=np.float32),
            radius=5.0
        )
        cameras = orbit.circular(n_frames=30, overlap=1)
        assert len(cameras) == 30

    def test_all_cameras_at_correct_distance(self):
        """All cameras should be at the orbit radius from the target."""
        target = np.array([1.0, 2.0, 3.0], dtype=np.float32)
        radius = 5.0
        orbit = OrbitPath(target=target, radius=radius)
        cameras = orbit.circular(n_frames=20, overlap=0)

        for cam in cameras:
            dist = np.linalg.norm(cam.position - target)
            assert np.isclose(dist, radius, atol=1e-4)

    def test_cameras_look_at_target(self):
        """All cameras should have forward vectors pointing toward target."""
        target = np.array([0, 0, 0], dtype=np.float32)
        orbit = OrbitPath(target=target, radius=3.0)
        cameras = orbit.circular(n_frames=12, overlap=0)

        for cam in cameras:
            forward = cam.get_forward_vector()
            expected = (target - cam.position) / np.linalg.norm(target - cam.position)
            assert np.allclose(forward, expected, atol=1e-5)

    def test_start_azimuth(self):
        """Custom start azimuth should shift all positions."""
        target = np.zeros(3, dtype=np.float32)
        orbit = OrbitPath(target=target, radius=5.0)

        cams_default = orbit.circular(n_frames=4, overlap=0, start_azimuth_deg=0.0)
        cams_offset = orbit.circular(n_frames=4, overlap=0, start_azimuth_deg=90.0)

        # First camera of default should be at +Z
        assert np.isclose(cams_default[0].position[2], 5.0, atol=1e-4)
        # First camera of offset should be at +X
        assert np.isclose(cams_offset[0].position[0], 5.0, atol=1e-4)


class TestEndToEndOriginalCameraOrbit:
    """Integration test: compute params + create orbit with pin."""

    def test_frame0_matches_original_camera(self):
        """Full workflow: params -> orbit -> frame 0 is exact original camera."""
        # Simulate SAM-3D-Body: mesh centered at [0.02, -0.15, -1.8]
        target = np.array([0.02, -0.15, -1.8], dtype=np.float32)
        original_fl = 600.0

        # Step 1: compute orbit params
        params = compute_original_camera_orbit_params(target)

        # Step 2: build pin camera
        pin = Camera(
            focal_length=(original_fl, original_fl),
            image_size=(512, 512),
            position=np.zeros(3, dtype=np.float32),
            rotation=np.eye(3, dtype=np.float32)
        )

        # Step 3: create orbit with pin
        template = Camera(
            focal_length=(original_fl, original_fl),
            image_size=(512, 512)
        )
        orbit = OrbitPath(
            target=params['target'],
            radius=params['radius'],
            pin_first_camera=pin
        )
        cameras = orbit.circular(
            n_frames=30,
            elevation_deg=params['elevation_deg'],
            start_azimuth_deg=params['start_azimuth_deg'],
            overlap=0,
            camera_template=template
        )

        # Frame 0 is the exact original camera
        assert np.allclose(cameras[0].position, [0, 0, 0])
        assert np.allclose(cameras[0].rotation, np.eye(3))
        assert cameras[0].fx == original_fl

        # Frame 1 is NOT at origin (it's the next orbit position)
        assert not np.allclose(cameras[1].position, [0, 0, 0])

        # All frames have correct focal length
        for cam in cameras:
            assert cam.fx == original_fl

        # All non-pinned frames are at the correct radius
        for cam in cameras[1:]:
            dist = np.linalg.norm(cam.position - target)
            assert np.isclose(dist, params['radius'], atol=1e-4)
